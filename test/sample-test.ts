import { Contract, ContractFactory } from "@ethersproject/contracts";
import { SignerWithAddress } from "@nomiclabs/hardhat-ethers/signers";
import assert from "assert";
import { ethers } from "hardhat";
import { providers, BigNumber } from "ethers";

let signer: SignerWithAddress;
let provider: providers.JsonRpcProvider;

let EtherStore: ContractFactory;
let etherStore: Contract;
let etherStoreAddress: string;

let Attack: ContractFactory;
let attack: Contract;
let attackAddress: string;

let depositedEthers = ethers.utils.parseEther("2");

async function logContractsBalances(state: string) {
  console.log(`${state} balances of the EtherStore contract are : ${await provider.getBalance(etherStoreAddress)}`);
  console.log(`${state} balances of the Attack contract are : ${await provider.getBalance(attackAddress)}`);
}

describe("EtherStore", function () {
  it("Deploy the EtherStore contract", async function () {

    [signer] = await ethers.getSigners();
    EtherStore = await ethers.getContractFactory("EtherStore");
    etherStore = await EtherStore.deploy();
    await etherStore.deployed();

    etherStoreAddress = etherStore.address;
    
    assert.ok(etherStoreAddress);
  });
  it("Fund EtherStore", async function() {
    provider = await ethers.provider;
    await etherStore.depositFunds({value: depositedEthers});
    const etherStoreBalances = await provider.getBalance(etherStoreAddress);

    assert.equal(etherStoreBalances.toString(), depositedEthers.toString());
  });
});

describe("Attack", async function() {
  it("Deploy the Attack contract", async function(){
    Attack = await ethers.getContractFactory("Attack");
    attack = await Attack.deploy(etherStoreAddress);
    await attack.deployed();

    attackAddress = attack.address;
    assert.ok(true);
  });

  it("Exploit the smart contract", async function() {
    await logContractsBalances("Initial");
    const exploit_tx = await attack.attack({value: ethers.utils.parseEther("1"), gasLimit: 30000000});
    await exploit_tx.wait(2);

    await logContractsBalances("Final");

    assert.ok(await provider.getBalance(etherStoreAddress).toString() <= ethers.utils.parseEther("1").toString());

  });
});